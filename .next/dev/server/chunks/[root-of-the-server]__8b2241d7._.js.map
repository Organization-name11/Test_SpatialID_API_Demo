{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Test_SpatialID_API_Demo/lib/ouranos-gex-lib-for-javascript/zfxy.ts"],"sourcesContent":["import { LngLat, LngLatWithAltitude } from \"./types\";\n\nexport type ZFXYTile = { z: number, f: number, x: number, y: number };\n\nexport function isZFXYTile(tile: any): tile is ZFXYTile {\n  return ('z' in tile && 'f' in tile && 'x' in tile && 'y' in tile);\n}\n\nexport const ZFXY_1M_ZOOM_BASE = 25 as const;\nexport const ZFXY_ROOT_TILE: ZFXYTile = { f: 0, x: 0, y: 0, z: 0 };\n\nconst rad2deg = 180 / Math.PI;\n\nexport function getParent(tile: ZFXYTile, steps: number = 1): ZFXYTile {\n  const { f,x,y,z } = tile;\n  if (steps <= 0) {\n    throw new Error('steps must be greater than 0');\n  }\n  if (steps > z) {\n    throw new Error(`Getting parent tile of ${tile}, ${steps} steps is not possible because it would go beyond the root tile (z=0)`);\n  }\n  return {\n    f: f >> steps,\n    x: x >> steps,\n    y: y >> steps,\n    z: z -  steps,\n  };\n}\n\nexport function getChildren(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\n  const {f,x,y,z} = tile;\n  return [\n    {f: f * 2,     x: x * 2,     y: y * 2,     z: z+1}, // f +0, x +0, y +0\n    {f: f * 2,     x: x * 2 + 1, y: y * 2,     z: z+1}, // f +0, x +1, y +0\n    {f: f * 2,     x: x * 2,     y: y * 2 + 1, z: z+1}, // f +0, x +0, y +1\n    {f: f * 2,     x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +0, x +1, y +1\n    {f: f * 2 + 1, x: x * 2,     y: y * 2,     z: z+1}, // f +1, x +0, y +0\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2,     z: z+1}, // f +1, x +1, y +0\n    {f: f * 2 + 1, x: x * 2,     y: y * 2 + 1, z: z+1}, // f +1, x +0, y +1\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +1, x +1, y +1\n  ];\n}\n\nexport function getSurrounding(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\n  const {f,x,y,z} = tile;\n  return [\n    zfxyWraparound({f: f, x: x,     y: y,     z: z}), // f +0, x +0, y +0\n    zfxyWraparound({f: f, x: x + 1, y: y,     z: z}), // f +0, x +1, y +0\n    zfxyWraparound({f: f, x: x,     y: y + 1, z: z}), // f +0, x +0, y +1\n    zfxyWraparound({f: f, x: x + 1, y: y + 1, z: z}), // f +0, x +1, y +1\n    zfxyWraparound({f: f, x: x - 1, y: y,     z: z}), // f +0, x -1, y +0\n    zfxyWraparound({f: f, x: x,     y: y - 1, z: z}), // f +0, x +0, y -1\n    zfxyWraparound({f: f, x: x - 1, y: y - 1, z: z}), // f +0, x -1, y -1\n    zfxyWraparound({f: f, x: x + 1, y: y - 1, z: z}), // f +0, x +1, y -1\n    zfxyWraparound({f: f, x: x - 1, y: y + 1, z: z}), // f +0, x -1, y +1\n  ];\n}\n\nexport function parseZFXYString(str: string): ZFXYTile | undefined {\n  const match = str.match(/^\\/?(\\d+)\\/(?:(\\d+)\\/)?(\\d+)\\/(\\d+)$/);\n  if (!match) {\n    return undefined;\n  }\n  return {\n    z: parseInt(match[1], 10),\n    f: parseInt(match[2] || '0', 10),\n    x: parseInt(match[3], 10),\n    y: parseInt(match[4], 10),\n  };\n}\n\n/** Returns the lng,lat of the northwest corner of the provided tile */\nexport function getLngLat(tile: ZFXYTile): LngLat {\n  const n = Math.PI - 2 * Math.PI * tile.y / Math.pow(2, tile.z);\n  return {\n    lng: tile.x / Math.pow(2, tile.z) * 360 - 180,\n    lat: rad2deg * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))),\n  };\n}\n\nexport function getCenterLngLat(tile: ZFXYTile): LngLat {\n  const x = tile.x * 2 + 1,\n        y = tile.y * 2 + 1,\n        z = tile.z + 1;\n  return getLngLat({x, y, z, f: 0});\n}\n\nexport function getCenterLngLatAlt(tile: ZFXYTile): LngLatWithAltitude {\n  return {\n    ...getCenterLngLat(tile),\n    alt: getFloor(tile) + ((2**ZFXY_1M_ZOOM_BASE) / (2**(tile.z + 1))),\n  };\n}\n\nexport function getBBox(tile: ZFXYTile): [LngLat, LngLat] {\n  const nw = getLngLat(tile),\n        se = getLngLat({...tile, y: tile.y + 1, x: tile.x + 1});\n  return [ nw, se ];\n}\n\n/** Returns the floor of the voxel, in meters */\nexport function getFloor(tile: ZFXYTile): number {\n  return tile.f * (2**ZFXY_1M_ZOOM_BASE) / (2**tile.z)\n}\n\nexport interface CalculateZFXYInput {\n  lat: number\n  lng: number\n  alt?: number\n  zoom: number\n}\n\nexport function calculateZFXY(input: CalculateZFXYInput): ZFXYTile {\n  const meters = typeof input.alt !== 'undefined' ? input.alt : 0;\n  if (meters <= -(2**ZFXY_1M_ZOOM_BASE) || meters >= (2**ZFXY_1M_ZOOM_BASE)) {\n    // TODO: make altitude unlimited?\n    throw new Error(`ZFXY only supports altitude between -2^${ZFXY_1M_ZOOM_BASE} and +2^${ZFXY_1M_ZOOM_BASE}.`);\n  }\n  const f = Math.floor(((2 ** input.zoom) * meters) / (2 ** ZFXY_1M_ZOOM_BASE));\n\n  // Algorithm adapted from tilebelt.js\n  const d2r = Math.PI / 180;\n  const sin = Math.sin(input.lat * d2r);\n  const z2 = 2 ** input.zoom;\n  let x = z2 * (input.lng / 360 + 0.5);\n  const y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n  // Wrap Tile X\n  x = x % z2;\n  if (x < 0) x = x + z2;\n\n  return {\n    f: f,\n    x: Math.floor(x),\n    y: Math.floor(y),\n    z: input.zoom,\n  };\n}\n\n/**\n * Fix a tile that has out-of-bounds coordinates by:\n * for the x and y coordinates: wrapping the coordinates around.\n * for the f coordinate: limiting to maximum or minimum.\n */\nexport function zfxyWraparound(tile: ZFXYTile): ZFXYTile {\n  const {z, f, x, y} = tile;\n  return {\n    z,\n    f: Math.max(Math.min(f, (2**z)), -(2**z)),\n    x: (x < 0) ? x + 2**z : x % 2**z,\n    y: (y < 0) ? y + 2**z : y % 2**z,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Test_SpatialID_API_Demo/lib/ouranos-gex-lib-for-javascript/zfxy_tilehash.ts"],"sourcesContent":["import { ZFXYTile, getChildren, getParent } from \"./zfxy\";\n\nexport function parseZFXYTilehash(th: string): ZFXYTile {\n  let negativeF = false;\n  if (th[0] === '-') {\n    negativeF = true;\n    th = th.substring(1);\n  }\n  let children = getChildren();\n  let lastChild: ZFXYTile;\n  for (const c of th) {\n    lastChild = {...children[parseInt(c, 10) - 1]};\n    children = getChildren(lastChild);\n  }\n  if (negativeF) {\n    lastChild.f = -lastChild.f;\n  }\n  return lastChild;\n}\n\nexport function generateTilehash(tile: ZFXYTile): string {\n  let {f,x,y,z} = tile;\n  const originalF = f;\n  let out = '';\n  while (z>0) {\n    const thisTile: ZFXYTile = { f: Math.abs(f), x: x, y: y, z: z };\n    const parent = getParent(thisTile);\n    const childrenOfParent = getChildren(parent);\n    const positionInParent = childrenOfParent.findIndex(\n      (child) => child.f === Math.abs(f) && child.x === x && child.y === y && child.z === z\n    );\n    out = (positionInParent + 1).toString() + out;\n    f = parent.f;\n    x = parent.x;\n    y = parent.y;\n    z = parent.z;\n  }\n  return (originalF < 0 ? '-' : '') + out;\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,SAAS,kBAAkB,EAAU;IAC1C,IAAI,YAAY;IAChB,IAAI,EAAE,CAAC,EAAE,KAAK,KAAK;QACjB,YAAY;QACZ,KAAK,GAAG,SAAS,CAAC;IACpB;IACA,IAAI,WAAW,IAAA,iKAAW;IAC1B,IAAI;IACJ,KAAK,MAAM,KAAK,GAAI;QAClB,YAAY;YAAC,GAAG,QAAQ,CAAC,SAAS,GAAG,MAAM,EAAE;QAAA;QAC7C,WAAW,IAAA,iKAAW,EAAC;IACzB;IACA,IAAI,WAAW;QACb,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC;IAC5B;IACA,OAAO;AACT;AAEO,SAAS,iBAAiB,IAAc;IAC7C,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG;IAChB,MAAM,YAAY;IAClB,IAAI,MAAM;IACV,MAAO,IAAE,EAAG;QACV,MAAM,WAAqB;YAAE,GAAG,KAAK,GAAG,CAAC;YAAI,GAAG;YAAG,GAAG;YAAG,GAAG;QAAE;QAC9D,MAAM,SAAS,IAAA,+JAAS,EAAC;QACzB,MAAM,mBAAmB,IAAA,iKAAW,EAAC;QACrC,MAAM,mBAAmB,iBAAiB,SAAS,CACjD,CAAC,QAAU,MAAM,CAAC,KAAK,KAAK,GAAG,CAAC,MAAM,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK;QAEtF,MAAM,CAAC,mBAAmB,CAAC,EAAE,QAAQ,KAAK;QAC1C,IAAI,OAAO,CAAC;QACZ,IAAI,OAAO,CAAC;QACZ,IAAI,OAAO,CAAC;QACZ,IAAI,OAAO,CAAC;IACd;IACA,OAAO,CAAC,YAAY,IAAI,MAAM,EAAE,IAAI;AACtC"}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Test_SpatialID_API_Demo/lib/ouranos-gex-lib-for-javascript/tilebelt.ts"],"sourcesContent":["import { BBox } from \"geojson\";\n\nconst d2r = Math.PI / 180,\n      r2d = 180 / Math.PI,\n      MAX_ZOOM = 28;\n\nexport function getBboxZoom(bbox: BBox) {\n  for (let z = 0; z < MAX_ZOOM; z++) {\n    const mask = 1 << (32 - (z + 1));\n    if (((bbox[0] & mask) !== (bbox[2] & mask)) ||\n        ((bbox[1] & mask) !== (bbox[3] & mask))) {\n      return z;\n    }\n  }\n\n  return MAX_ZOOM;\n}\n\n/**\n * Get the smallest tile to cover a bbox\n */\nexport function bboxToTile(bboxCoords: BBox, minZoom?: number): Array<number> {\n  const min = pointToTile(bboxCoords[0], bboxCoords[1], 32);\n  const max = pointToTile(bboxCoords[2], bboxCoords[3], 32);\n  const bbox: BBox = [min[0], min[1], max[0], max[1]];\n\n  const z = Math.min(getBboxZoom(bbox), typeof minZoom !== 'undefined' ? minZoom : MAX_ZOOM);\n  if (z === 0) return [0, 0, 0];\n  const x = bbox[0] >>> (32 - z);\n  const y = bbox[1] >>> (32 - z);\n  return [x, y, z];\n}\n\n/**\n * Get the tile for a point at a specified zoom level\n */\nexport function pointToTile(lon: number, lat: number, z: number) {\n  var tile = pointToTileFraction(lon, lat, z);\n  tile[0] = Math.floor(tile[0]);\n  tile[1] = Math.floor(tile[1]);\n  return tile;\n}\n\n/**\n * Get the precise fractional tile location for a point at a zoom level\n */\nfunction pointToTileFraction(lon: number, lat: number, z: number) {\n  var sin = Math.sin(lat * d2r),\n      z2 = Math.pow(2, z),\n      x = z2 * (lon / 360 + 0.5),\n      y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n  // Wrap Tile X\n  x = x % z2;\n  if (x < 0) x = x + z2;\n  return [x, y, z];\n}\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAM,MAAM,KAAK,EAAE,GAAG,KAChB,MAAM,MAAM,KAAK,EAAE,EACnB,WAAW;AAEV,SAAS,YAAY,IAAU;IACpC,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;QACjC,MAAM,OAAO,KAAM,KAAK,CAAC,IAAI,CAAC;QAC9B,IAAI,AAAC,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,KACpC,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,GAAI;YAC3C,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAKO,SAAS,WAAW,UAAgB,EAAE,OAAgB;IAC3D,MAAM,MAAM,YAAY,UAAU,CAAC,EAAE,EAAE,UAAU,CAAC,EAAE,EAAE;IACtD,MAAM,MAAM,YAAY,UAAU,CAAC,EAAE,EAAE,UAAU,CAAC,EAAE,EAAE;IACtD,MAAM,OAAa;QAAC,GAAG,CAAC,EAAE;QAAE,GAAG,CAAC,EAAE;QAAE,GAAG,CAAC,EAAE;QAAE,GAAG,CAAC,EAAE;KAAC;IAEnD,MAAM,IAAI,KAAK,GAAG,CAAC,YAAY,OAAO,OAAO,YAAY,cAAc,UAAU;IACjF,IAAI,MAAM,GAAG,OAAO;QAAC;QAAG;QAAG;KAAE;IAC7B,MAAM,IAAI,IAAI,CAAC,EAAE,KAAM,KAAK;IAC5B,MAAM,IAAI,IAAI,CAAC,EAAE,KAAM,KAAK;IAC5B,OAAO;QAAC;QAAG;QAAG;KAAE;AAClB;AAKO,SAAS,YAAY,GAAW,EAAE,GAAW,EAAE,CAAS;IAC7D,IAAI,OAAO,oBAAoB,KAAK,KAAK;IACzC,IAAI,CAAC,EAAE,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE;IAC5B,IAAI,CAAC,EAAE,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE;IAC5B,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,oBAAoB,GAAW,EAAE,GAAW,EAAE,CAAS;IAC9D,IAAI,MAAM,KAAK,GAAG,CAAC,MAAM,MACrB,KAAK,KAAK,GAAG,CAAC,GAAG,IACjB,IAAI,KAAK,CAAC,MAAM,MAAM,GAAG,GACzB,IAAI,KAAK,CAAC,MAAM,OAAO,KAAK,GAAG,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,KAAK,EAAE;IAEpE,cAAc;IACd,IAAI,IAAI;IACR,IAAI,IAAI,GAAG,IAAI,IAAI;IACnB,OAAO;QAAC;QAAG;QAAG;KAAE;AAClB"}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Test_SpatialID_API_Demo/lib/ouranos-gex-lib-for-javascript/index.ts"],"sourcesContent":["import { LngLatWithAltitude } from \"./types\";\nimport { calculateZFXY, getBBox, getChildren, getFloor, getParent, isZFXYTile, parseZFXYString, ZFXYTile, zfxyWraparound, getSurrounding, getCenterLngLatAlt } from \"./zfxy\";\nimport { generateTilehash, parseZFXYTilehash } from \"./zfxy_tilehash\";\nimport turfBBox from '@turf/bbox';\nimport turfBooleanIntersects from '@turf/boolean-intersects';\nimport type { Geometry, Polygon } from \"geojson\";\nimport { bboxToTile, pointToTile } from \"./tilebelt\";\n\nconst DEFAULT_ZOOM = 25 as const;\n\nexport class Space {\n  center: LngLatWithAltitude\n  alt: number\n  zoom: number\n\n  zfxy: ZFXYTile\n\n  id: string\n  zfxyStr: string\n  tilehash: string\n\n  /**\n   * Create a new Space\n   *\n   * @param input A LngLatWithAltitude or string containing either a ZFXY or tilehash-encoded ZFXY.\n   * @param zoom Optional. Defaults to 25 when `input` is LngLatWithAltitude. Ignored when ZXFY or tilehash is provided.\n   */\n  constructor(input: LngLatWithAltitude | ZFXYTile | string, zoom?: number) {\n    if (typeof input === 'string') {\n      // parse string\n      let zfxy = parseZFXYString(input) || parseZFXYTilehash(input);\n      if (zfxy) {\n        this.zfxy = zfxy;\n        this._regenerateAttributesFromZFXY();\n      } else {\n        throw new Error(`parse ZFXY failed with input: ${input}`);\n      }\n      return;\n    } else if (isZFXYTile(input)) {\n      this.zfxy = input;\n      this._regenerateAttributesFromZFXY();\n      return;\n    } else {\n      this.zfxy = calculateZFXY({\n        ...input,\n        zoom: (typeof zoom !== 'undefined') ? zoom : DEFAULT_ZOOM,\n      });\n    }\n\n    this._regenerateAttributesFromZFXY();\n  }\n\n  /* - PUBLIC API - */\n\n  up(by: number = 1) {\n    return this.move({f: by});\n  }\n\n  down(by: number = 1) {\n    return this.move({f: -by});\n  }\n\n  north(by: number = 1) {\n    return this.move({y: by});\n  }\n\n  south(by: number = 1) {\n    return this.move({y: -by});\n  }\n\n  east(by: number = 1) {\n    return this.move({x: by});\n  }\n\n  west(by: number = 1) {\n    return this.move({x: -by});\n  }\n\n  move(by: Partial<Omit<ZFXYTile, 'z'>>) {\n    const newSpace = new Space(this.zfxy);\n    newSpace.zfxy = zfxyWraparound({\n      z: newSpace.zfxy.z,\n      f: newSpace.zfxy.f + (by.f || 0),\n      x: newSpace.zfxy.x + (by.x || 0),\n      y: newSpace.zfxy.y + (by.y || 0),\n    });\n    newSpace._regenerateAttributesFromZFXY();\n    return newSpace;\n  }\n\n  parent(atZoom?: number) {\n    const steps = (typeof atZoom === 'undefined') ? 1 : this.zfxy.z - atZoom;\n    return new Space(getParent(this.zfxy, steps));\n  }\n\n  children() {\n    return getChildren(this.zfxy).map((tile) => new Space(tile));\n  }\n\n  /** Return an array of Space objects at the same zoom level that surround this Space\n   * object. This method does not return the Space object itself, so the array will\n   * contain 26 Space objects.\n   */\n  surroundings(): Space[] {\n    return [\n      ...(\n        getSurrounding(this.zfxy)\n        .filter(({z,f,x,y}) => `/${z}/${f}/${x}/${y}` !== this.zfxyStr)\n        .map((tile) => new Space(tile))\n      ),\n      ...(\n        getSurrounding(this.up().zfxy)\n        .map((tile) => new Space(tile))\n      ),\n      ...(\n        getSurrounding(this.down().zfxy)\n        .map((tile) => new Space(tile))\n      ),\n    ];\n  }\n\n  /** Returns true if a point lies within this Space. If the position's altitude is not\n   * specified, it is ignored from the calculation.\n   */\n  contains(position: LngLatWithAltitude) {\n    const geom = this.toGeoJSON();\n    const point = {\n      type: 'Point',\n      coordinates: [position.lng, position.lat],\n    };\n    const floor = this.alt;\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\n    return (\n      turfBooleanIntersects(geom, point) &&\n      (typeof position.alt !== 'undefined' === true ?\n        position.alt >= floor && position.alt < ceil\n        :\n        true\n      )\n    );\n  }\n\n  /** Calculates the polygon of this Space and returns a 2D GeoJSON Polygon. */\n  toGeoJSON(): Polygon {\n    const [nw, se] = getBBox(this.zfxy);\n    return {\n      type: 'Polygon',\n      coordinates: [\n        [\n          [nw.lng, nw.lat],\n          [nw.lng, se.lat],\n          [se.lng, se.lat],\n          [se.lng, nw.lat],\n          [nw.lng, nw.lat],\n        ],\n      ],\n    };\n  }\n\n  /** Calculates the 3D polygon of this Space and returns the vertices of that polygon. */\n  vertices3d(): [number, number, number][] {\n    const [nw, se] = getBBox(this.zfxy);\n    const floor = getFloor(this.zfxy);\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\n    return [\n      [nw.lng, nw.lat, floor],\n      [nw.lng, se.lat, floor],\n      [se.lng, se.lat, floor],\n      [se.lng, nw.lat, floor],\n      [nw.lng, nw.lat, ceil],\n      [nw.lng, se.lat, ceil],\n      [se.lng, se.lat, ceil],\n      [se.lng, nw.lat, ceil],\n    ];\n  }\n\n  static getSpaceById(id: string, zoom?: number) {\n    return new Space(id, zoom);\n  }\n\n  static getSpaceByLocation(loc: LngLatWithAltitude, zoom?: number) {\n    return new Space(loc, zoom);\n  }\n\n  static getSpaceByZFXY(zfxyStr: string) {\n    return new Space(zfxyStr);\n  }\n\n  /** Calculates the smallest spatial ID to fully contain the polygon. Currently only supports 2D polygons. */\n  static boundingSpaceForGeometry(geom: Geometry, minZoom?: number): Space {\n    minZoom = minZoom || 25;\n    const bbox = turfBBox(geom);\n    const largestTile = bboxToTile(bbox, minZoom);\n    const [ x, y, z ] = largestTile;\n    return new Space({x, y, z, f: 0});\n  }\n\n  /** Calculate an array of spaces that make up the polygon. Currently only supports 2D polygons. */\n  static spacesForGeometry(geom: Geometry, zoom: number): Space[] {\n    const z = zoom;\n\n    if (z === 0) {\n      // not recommended.\n      return [new Space('0/0/0/0')];\n    }\n\n    if (geom.type === 'GeometryCollection') {\n      throw new Error('GeometryCollection not supported');\n    }\n\n    // this can be optimized a lot!\n    const bbox = turfBBox(geom),\n          min = pointToTile(bbox[0], bbox[1], 32),\n          max = pointToTile(bbox[2], bbox[3], 32),\n          minX = (Math.min(min[0], max[0])) >>> (32 - z),\n          minY = (Math.min(min[1], max[1])) >>> (32 - z),\n          maxX = (Math.max(max[0], min[0]) >>> (32 - z)) + 1,\n          maxY = (Math.max(max[1], min[1]) >>> (32 - z)) + 1,\n          spaces: Space[] = [];\n\n    // scanline polygon fill algorithm\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        const space = new Space({x, y, z, f: 0});\n        if (turfBooleanIntersects(geom, space.toGeoJSON())) {\n          spaces.push(space);\n        }\n      }\n    }\n    return spaces;\n  }\n\n  private _regenerateAttributesFromZFXY() {\n    this.alt = getFloor(this.zfxy);\n    this.center = getCenterLngLatAlt(this.zfxy);\n    this.zoom = this.zfxy.z;\n    this.id = this.tilehash = generateTilehash(this.zfxy);\n    this.zfxyStr = `/${this.zfxy.z}/${this.zfxy.f}/${this.zfxy.x}/${this.zfxy.y}`;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 684, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Test_SpatialID_API_Demo/pages/api/spatial-id.ts"],"sourcesContent":["import { Space } from '../../lib/ouranos-gex-lib-for-javascript/index';\n\nexport default function handler(req, res) {\n  const { lat, lon, zoom = '25', alt } = req.query;\n\n  const latNum = parseFloat(lat);\n  const lonNum = parseFloat(lon);\n  const zoomNum = parseInt(zoom, 10);\n  const altNum = alt !== undefined ? parseFloat(alt) : undefined;\n\n  if (Number.isNaN(latNum) || Number.isNaN(lonNum)) {\n    res.status(400).json({ error: 'lat と lon は必須です' });\n    return;\n  }\n  if (latNum < -85.0511287798 || latNum > 85.0511287798) {\n    res.status(400).json({ error: 'lat の範囲は ±85.0511287798' });\n    return;\n  }\n  if (lonNum < -180 || lonNum > 180) {\n    res.status(400).json({ error: 'lon の範囲は ±180' });\n    return;\n  }\n  if (zoomNum < 0 || zoomNum > 35) {\n    res.status(400).json({ error: 'zoom は 0〜35' });\n    return;\n  }\n\n  try {\n    const space = new Space({ lng: lonNum, lat: latNum, alt: altNum }, zoomNum);\n    res.setHeader('Access-Control-Allow-Origin', '*'); // デモ用CORS\n    res.status(200).json({\n      result: {\n        zfxyStr: space.zfxyStr,\n        tilehash: space.tilehash,\n        zfxy: space.zfxy,\n        zoom: space.zoom,\n        center: space.center,\n        alt: space.alt\n      }\n    });\n  } catch (e) {\n    res.setHeader('Access-Control-Allow-Origin', '*'); // デモ用CORS\n    res.status(500).json({ error: String(e) });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;AAEe,SAAS,QAAQ,GAAG,EAAE,GAAG;IACtC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,KAAK;IAEhD,MAAM,SAAS,WAAW;IAC1B,MAAM,SAAS,WAAW;IAC1B,MAAM,UAAU,SAAS,MAAM;IAC/B,MAAM,SAAS,QAAQ,YAAY,WAAW,OAAO;IAErD,IAAI,OAAO,KAAK,CAAC,WAAW,OAAO,KAAK,CAAC,SAAS;QAChD,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAkB;QAChD;IACF;IACA,IAAI,SAAS,CAAC,iBAAiB,SAAS,eAAe;QACrD,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA0B;QACxD;IACF;IACA,IAAI,SAAS,CAAC,OAAO,SAAS,KAAK;QACjC,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAgB;QAC9C;IACF;IACA,IAAI,UAAU,KAAK,UAAU,IAAI;QAC/B,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAc;QAC5C;IACF;IAEA,IAAI;QACF,MAAM,QAAQ,IAAI,4JAAK,CAAC;YAAE,KAAK;YAAQ,KAAK;YAAQ,KAAK;QAAO,GAAG;QACnE,IAAI,SAAS,CAAC,+BAA+B,MAAM,UAAU;QAC7D,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YACnB,QAAQ;gBACN,SAAS,MAAM,OAAO;gBACtB,UAAU,MAAM,QAAQ;gBACxB,MAAM,MAAM,IAAI;gBAChB,MAAM,MAAM,IAAI;gBAChB,QAAQ,MAAM,MAAM;gBACpB,KAAK,MAAM,GAAG;YAChB;QACF;IACF,EAAE,OAAO,GAAG;QACV,IAAI,SAAS,CAAC,+BAA+B,MAAM,UAAU;QAC7D,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO,OAAO;QAAG;IAC1C;AACF"}}]
}